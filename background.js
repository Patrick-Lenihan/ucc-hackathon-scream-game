let subgameBackground = [
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
]


let request;
let fpsInterval = 1000 / 15;
let then = Date.now();

let playerImage = new Image();
let grassImage = new Image();
let bat = new Image();
let rock = new Image();
let average = 0;
let canvas = document.getElementById("canvas")
let context = canvas.getContext("2d");
let backgroundCount = 0;
let jumpcount = 0;
let clicks = 0;
let tilesPerRow = 10;
let tileSize = 16;
let backgroundCountX = 0;
let backgroundCountY = 0;
playerImage.src = "running.png";
grassImage.src = "tiles.png";
rock.src = "rock.png";
bat.src = "silverbat.png";
let player = {
  x: 50,
  y: 240,
  height: 65,
  width: 65,
  frameX: 7,
  frameY: 0,
  xChange: 0,
  yChange: 0,
  health: 100,
  state: "running",
  speed: -30
};


let rock1 = {
  x: 512,
  y: 280,
  height: 10,
  width: 10
}
let rock2 = {
  x: 712,
  y: 280,
  height: 10,
  width: 10
}
let bat1 = {
  x: 512,
  y: 232,
  height: 48,
  width: 32,
  frameX: 0,
  frameY: 1
}

document.addEventListener("DOMContentLoaded", init, false);


function init () {
    context.fillStyle = "lightblue";
    drawAll();
}


function drawAll() {

    request = window.requestAnimationFrame(drawAll);
    let now = Date.now();
    let elapsed = now - then;
    if (elapsed <= fpsInterval) {
        return;
    };
    then = now - (elapsed % fpsInterval);
    
    context.clearRect(0,0,512,320);
    context.fillRect(50, 300-average, 20, 20);
    context.fillRect(0, 0, 512, 320);

    subgame()

    if (player.health >0) {

      if (player.health >0) {

      
        if(player.state === "running"){
          player.frameX = (player.frameX + 1) % 8;
          context.drawImage(playerImage, 
          player.width * player.frameX, player.height * player.frameY,
          player.width, player.height,
          player.x, player.y, player.width, player.height);
        } else {
          
          player.y += player.speed;
          player.speed = player.speed + 3; 

          if (player.y > 240){
            player.y = 239;
            player.state = "running";
            playerImage.src = "running.png";
            player.speed = -30;
            player.width = 65
            player.frameX = 0;
            player.frameY = 0;
            player.height = 65;
          }
          player.frameX = (player.frameX + 1) % 8;
          context.drawImage(playerImage, 
            player.width * player.frameX, player.height * player.frameY,
            player.width, player.height,
            player.x, player.y, player.width, player.height);// source x of tc, sorcey of tc , source width, source height , dest x, dest y, destwidth, destheight
          
        }
        if (average > 40) {
          // checking if the average is greater than 100 and then swithching the source to 100
          player.state = "jumping";
        }
  
      }
    }

}

function subgame() {
  tilesPerRow = 6;
  backgroundCount = backgroundCount + 1
  if (backgroundCount === 16) {
    backgroundCount = 0;
  }
  for (let r = 0; r < 20; r += 1) {
    for (let c = 0; c < 35; c += 1) {
      let tile = subgameBackground[r][c];
      if (tile >= 0) {
        let tileRow = Math.floor(tile / tilesPerRow);
        let tileCol = Math.floor(tile % tilesPerRow);
        context.drawImage(grassImage, tileCol * tileSize, tileRow * tileSize, tileSize, tileSize,
          (c * tileSize) - backgroundCount * 2, r * tileSize, tileSize, tileSize);
      }
    }
  }

  context.drawImage(rock, rock1.x, rock1.y - 20, rock1.width * 5, rock1.height * 5);
                rock1.x = rock1.x - 6;
                if (rock1.x < 0 - rock1.width) {
                    rock1.x = canvas.width;
                }
                context.drawImage(rock, rock2.x, rock2.y - 20, rock2.width * 5, rock2.height * 5);
                rock2.x = rock2.x - 6;
                if (rock2.x < 0 - rock2.width) {
                    rock2.x = canvas.width + 20;
                }

                context.drawImage(bat,
                    bat1.width * bat1.frameX, bat1.height * bat1.frameY,
                    bat1.width, bat1.height,
                    bat1.x, bat1.y - 70, bat1.width, bat1.height);
                bat1.frameX = (bat1.frameX + 1) % 4;
                bat1.x = bat1.x - 9;
                if (bat1.x < 0 - bat1.width) {
                  bat1.x = canvas.width;
              }

              collision(player, rock1)
              collision(player, rock2)
              collision(player, bat1)

}


function collision(player, obstacle) {
  // cases of collision
  if (!((player.x > obstacle.x + obstacle.width) ||
      ((player.x - 15 + player.width < obstacle.x)) ||
      ((player.y - 10 + player.height < obstacle.y)) ||
      ((player.y > obstacle.y)))) {
      console.log("Done")
  }
}




navigator.mediaDevices.getUserMedia({
    audio: true
  })
    .then(function(stream) {
      const audioContext = new AudioContext();
      const analyser = audioContext.createAnalyser();
      const microphone = audioContext.createMediaStreamSource(stream);
      const scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);
  
      analyser.smoothingTimeConstant = .8;
      analyser.fftSize = 1024;
  
      microphone.connect(analyser);
      analyser.connect(scriptProcessor);
      scriptProcessor.connect(audioContext.destination);
      scriptProcessor.onaudioprocess = function() {
        const array = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(array);
        const arraySum = array.reduce((a, value) => a + value, 0);
        average = arraySum / array.length;
        console.log(Math.round(average));


        //colorPids(average);
      };
    })
    .catch(function(err) {
      /* handle the error */
      console.error(err);
    });

